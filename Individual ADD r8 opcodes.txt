/* individual opcodes from before i made a universal one

/**
 * @brief Add A to A, Leaves result in A AKA (ADD A, A)
 * @param cpu point to GB_CPU
/
void ADD_a2a(struct GB_CPU* cpu){
    
    uint16_t i = 0; //temp variable that can hold overflow

    i = cpu->_r.a + cpu->_r.a; // Add A to A, order doesnt matter bc addition
    cpu->_r.f = 0; // Clear flags

    if(!(i & 255)){
        cpu->_r.f |= Z_FLAG; // TLDR: if i = 0 set f to 0, 0x80 is the zero denotation, the if checks if the result of the math is a value b/t 1-255 if not then proceed.
    }

    if(i > 255){
        cpu->_r.f |= C_FLAG; //if overflow happened, add overflow flag to flag stack
    }

    cpu->_r.a = (uint8_t)i; //sets result to a 
    cpu->_r.m = 1; cpu->_r.t = 4; //Time of last cycle
    cpu->_c.m += cpu->_r.m; cpu->_c.t += cpu->_r.t; //Total time of cycles
}

/**
 * @brief Add B to A, Leaves result in A AKA (ADD A, B)
 * @param cpu point to GB_CPU
 /
void ADD_b2a(struct GB_CPU* cpu){
    
    uint16_t i = 0; //temp variable that can hold overflow

    i = cpu->_r.a + cpu->_r.b; // Add B to A, order doesnt matter bc addition
    cpu->_r.f = 0; // Clear flags

    if(!(i & 255)){
        cpu->_r.f |= Z_FLAG; // TLDR: if i = 0 set f to 0, 0x80 is the zero denotation, the if checks if the result of the math is a value b/t 1-255 if not then proceed.
    }

    if(i > 255){
        cpu->_r.f |= C_FLAG; //if overflow happened, add overflow flag to flag stack
    }

    cpu->_r.a = (uint8_t)i; //sets result to a 
    cpu->_r.m = 1; cpu->_r.t = 4; //Time of last cycle
    cpu->_c.m += cpu->_r.m; cpu->_c.t += cpu->_r.t; //Total time of cycles
}

/**
 * @brief Add C to A, Leaves result in A AKA (ADD A, C)
 * @param cpu point to GB_CPU
 /
void ADD_c2a(struct GB_CPU* cpu){
    
    uint16_t i = 0; //temp variable that can hold overflow

    i = cpu->_r.a + cpu->_r.c; // Add C to A, order doesnt matter bc addition
    cpu->_r.f = 0; // Clear flags

    if(!(i & 255)){
        cpu->_r.f |= Z_FLAG; // TLDR: if i = 0 set f to 0, 0x80 is the zero denotation, the if checks if the result of the math is a value b/t 1-255 if not then proceed.
    }

    if(i > 255){
        cpu->_r.f |= C_FLAG; //if overflow happened, add overflow flag to flag stack
    }

    cpu->_r.a = (uint8_t)i; //sets result to a 
    cpu->_r.m = 1; cpu->_r.t = 4; //Time of last cycle
    cpu->_c.m += cpu->_r.m; cpu->_c.t += cpu->_r.t; //Total time of cycles
}

/**
 * @brief Add D to A, Leaves result in A AKA (ADD A, D)
 * @param cpu point to GB_CPU
 /
void ADD_d2a(struct GB_CPU* cpu){
    
    uint16_t i = 0; //temp variable that can hold overflow

    i = cpu->_r.a + cpu->_r.d; // Add D to A, order doesnt matter bc addition
    cpu->_r.f = 0; // Clear flags

    if(!(i & 255)){
        cpu->_r.f |= Z_FLAG; // TLDR: if i = 0 set f to 0, 0x80 is the zero denotation, the if checks if the result of the math is a value b/t 1-255 if not then proceed.
    }

    if(i > 255){
        cpu->_r.f |= C_FLAG; //if overflow happened, add overflow flag to flag stack
    }

    cpu->_r.a = (uint8_t)i; //sets result to a 
    cpu->_r.m = 1; cpu->_r.t = 4; //Time of last cycle
    cpu->_c.m += cpu->_r.m; cpu->_c.t += cpu->_r.t; //Total time of cycles
}

/**
 * @brief Add E to A, Leaves result in A AKA (ADD A, E)
 * @param cpu point to GB_CPU
 /
void ADD_e2a(struct GB_CPU* cpu){
    
    uint16_t i = 0; //temp variable that can hold overflow

    i = cpu->_r.a + cpu->_r.e; // Add E to A, order doesnt matter bc addition
    cpu->_r.f = 0; // Clear flags

    if(!(i & 255)){
        cpu->_r.f |= Z_FLAG; // TLDR: if i = 0 set f to 0, 0x80 is the zero denotation, the if checks if the result of the math is a value b/t 1-255 if not then proceed.
    }

    if(i > 255){
        cpu->_r.f |= C_FLAG; //if overflow happened, add overflow flag to flag stack
    }

    cpu->_r.a = (uint8_t)i; //sets result to a 
    cpu->_r.m = 1; cpu->_r.t = 4; //Time of last cycle
    cpu->_c.m += cpu->_r.m; cpu->_c.t += cpu->_r.t; //Total time of cycles
}

/**
 * @brief Add H to A, Leaves result in A AKA (ADD A, H)
 * @param cpu point to GB_CPU
 /
void ADD_h2a(struct GB_CPU* cpu){
    
    uint16_t i = 0; //temp variable that can hold overflow

    i = cpu->_r.a + cpu->_r.h; // Add H to A, order doesnt matter bc addition
    cpu->_r.f = 0; // Clear flags

    if(!(i & 255)){
        cpu->_r.f |= Z_FLAG; // TLDR: if i = 0 set f to 0, 0x80 is the zero denotation, the if checks if the result of the math is a value b/t 1-255 if not then proceed.
    }

    if(i > 255){
        cpu->_r.f |= C_FLAG; //if overflow happened, add overflow flag to flag stack
    }

    cpu->_r.a = (uint8_t)i; //sets result to a 
    cpu->_r.m = 1; cpu->_r.t = 4; //Time of last cycle
    cpu->_c.m += cpu->_r.m; cpu->_c.t += cpu->_r.t; //Total time of cycles
}

/**
 * @brief Add L to A, Leaves result in A AKA (ADD A, L)
 * @param cpu point to GB_CPU
 /
void ADD_l2a(struct GB_CPU* cpu){
    
    uint16_t i = 0; //temp variable that can hold overflow

    i = cpu->_r.a + cpu->_r.l; // Add L to A, order doesnt matter bc addition
    cpu->_r.f = 0; // Clear flags

    if(!(i & 255)){
        cpu->_r.f |= Z_FLAG; // TLDR: if i = 0 set f to 0, 0x80 is the zero denotation, the if checks if the result of the math is a value b/t 1-255 if not then proceed.
    }

    if(i > 255){
        cpu->_r.f |= C_FLAG; //if overflow happened, add overflow flag to flag stack
    }

    cpu->_r.a = (uint8_t)i; //sets result to a 
    cpu->_r.m = 1; cpu->_r.t = 4; //Time of last cycle
    cpu->_c.m += cpu->_r.m; cpu->_c.t += cpu->_r.t; //Total time of cycles
}

*/